## 一、题目描述

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。

**示例 1：**

```
输入：n = 1
输出：true
解释：20 = 1
```

**示例 2：**

```
输入：n = 16
输出：true
解释：24 = 16
```

**示例 3：**

```
输入：n = 3
输出：false
```

**提示：**

-   `-231 <= n <= 231 - 1`

**进阶：**你能够不使用循环/递归解决此问题吗？

## 二、解题思路

看到这个题的第一想法是什么呢？

判断是不是`2`的幂，那不就是判断这个数能不能被`2`整除嘛

因此我们可以使用循环去做除以`2`的操作，直到最后商为`0`，做除法期间，判断余数是不是`1`

如果出现`1`，那么这个数就不能被`2`整除了

**示例代码**

```java
public boolean isPowerOfTwo(int n) {
  if (n<=0) return false;
  if (n==1) return true;
  while (n > 1) {
    if ((n % 2) == 1) return false;
    n = n >> 1;
  }
  return true;
}
```

+ 时间复杂度为 `O(nlogn)`
+ 空间复杂度为`O(1)`

这段代码还可以优化一下，比如减少循环内的判断

```java
public boolean isPowerOfTwo(int n) {
  if (n < 1)
  	return false;
  while (n % 2 == 0) {
  	n = n >> 1;
  }
  return n == 1;
}
```

这样也不是不能解决问题，那么我们能不能不用循环呢？

在leetcode官解中看到一个取巧的方法，从 n 的取值，可以看出最大值为 `2^31-1`，那么2的幂最大值则为 `2^30`，也就表示用 `2^30` 去除以 `n` ，余数为`0`，这个数就是`2`的幂

**代码**

```java
static final int BIG = 1 << 30;

public boolean isPowerOfTwo(int n) {
  return n > 0 && BIG % n == 0;
}
```

- 时间复杂度：`O(1)`。
- 空间复杂度：`O(1)`。

那么是不是还有更更更加优雅的解法呢？

还有的，可以使用二进制，一个数是`2`的幂，那么这个数转化成二进制以后，这里面一定只有一个`1`，其余位数全是0。

我们可以利用一下这个特点，假如我们把这个`1`去掉，然后判断其他位是不是`0`就可以了。

我们可以使用位运算，使用 & 按位运算：`n & (n-1)`

4 转化成二进制是 0100，当4做减一操作以后，二进制数变成了`0011`，这时候进行 & 操作，最后的结果一定是 0 。

如果一个数不是`2`的幂，那么转化成二进制以后，里面最少有 `2` 个`1`的存在，例如 5 转化成二进制位 `0101`，当 5 做减一操作以后，二进制数变成了`0100`，这个数跟原数进行按位与操作，因为最高位上的`1`没有改变，所以结果不是`0`

**代码示例**

```java
public boolean isPowerOfTwo(int n) {
  return n > 0 && (n & (n - 1)) == 0;
}
```

- 时间复杂度：`O(1)`。
- 空间复杂度：`O(1)`。

负数的补码在计算机中是按照补码的方式存储的，−*n* 的二进制表示为 *n* 的二进制表示的每一位取反再加上 1，因此，如果 *n* 是正整数并且 `n & (-n) = n`，那么 *n* 就是 22 的幂。

```java
public boolean isPowerOfTwo(int n) {
  return n > 0 && (n & -n) == n;
}
```
